This video discusses tracking branches. We will start with the tracking branch overview. A tracking branch is a local branch that represents a remote branch. Locally, a tracking branch name starts with the remote name then a forward slash and then the branch name. If you clone a repository, you'll have a default local tracking branch. In this example, the remote repository contains a master branch with three commits. On the remote repository, the head reference points to the default branch that will be checked out when the repository is cloned. In this case, the default branch is named master. When we clone the remote repository, the same three commits, master branch label and head reference will be copied to the local repository. You can see that the commit graph on the remote repository looks exactly like this part of the commit graph locally. After the clone, you will have the master branch checked out. You can see that there is an additional branch label on the local repository. This is the tracking branch. It represents the remote master branch. Origin is a shortcut for the URL to the remote repository, and master is the name of the branch on the remote repository. Because the clone just happened, these two repositories are synchronized. All of the master branch labels point to commit C. That includes the local master branch label, the tracking master branch label and the remote master branch label. You can see that these three branches are related. Right now they each contain the same three commits. A tracking branch is related to its associated remote branch and local branch, but they are decoupled. Tracking branches updates separately from both the remote branch and the local branch. This is because tracking branches are only updated with network commands like clone, fetch, pull and push. The tracking branch acts as a sort of intermediary between the local and remote branches. In this example, our tracking branch points to commit C. This means that at the time of the most recent network command, commit C was the latest commit on the remote master branch. Locally, we then created commit D. This moves the head reference and master branch label to commit D. The tracking branch label stays behind because it only moves with network commands. Committing is a local command. If we look at the remote repository, we can see that since our last network command, someone pushed a new commit E. We are now in a state where the three master branch labels point to different commits. The local master branch label points to commit D, the master tracking branch label points to commit C, and the remote master branch label points to commit E. The three related branches are no longer in sync. Next, we will discuss viewing tracking branch names. By default, the git branch command only lists the names of local branches, use the all option of the git branch command to display all local and tracking branch names. Let's look at an example. First, we clone a bitbucket remote repository named project e. This will create a git managed directory named project e. We then change to that directory. We first execute a git branch command. You can see that it shows only the local master branch and because of the asterisk, we have the master branch checked out. We then execute the git branch command passing in the all option. The first branch is the local master branch. The second line is really not a unique branch, but is a symbolic reference that we will discuss shortly. The third line shows that we have a tracking branch that tracks the master branch on the remote repository. This tracking branch was created automatically during the git clone. If you look at this list, only the first and third lines represent unique branches, with the second line representing a symbolic reference to an existing branch. When using the all option with the git branch command, we saw that there is a reference named remote/origin/head. This is a symbolic reference, meaning that it is a reference that points to another reference. This specifies the default remote tracking branch. This allows you to only type the remote name instead of the whole tracking branch name in git commands. Let's look at an example. We start by executing the git branch command with the all option. We have one local branch named master and it is checked out. The default remote tracking branch has been set to origin/master. The third line says that the master branch has been set up as a tracking branch. Let's say that we want to see the commits of our master tracking branch. One way to do that is to specify origin/master as the argument of the git log command. Here we see that the tracking branch has two commits. Because we have a default remote tracking branch, we can execute the git log command again, but this time we can just specify origin as the argument, and receive the same results. You can change the default remote tracking branch locally using the git remote set head command. Let's look at an example. We start by executing the git branch command with the all option. We can see that there are two local branches; develop, which is checked out and master. We can see that the default remote tracking branch has been set to origin/master. We see that the develop and master branches had been set up as tracking branches. Let's say that we mostly commit to the develop branch, and for convenience we want to make that the default remote tracking branch. We execute the git remote set command, specifying origin as the remote name and develop as the default branch. We then execute git branch again and now we can see that our default branch is set to origin/develop. This means that in any git command where we would have specified origin/develop, we can simply specify origin instead. We have just seen how to change the default remote tracking branch in your local repository. In bitbucket, you can change the default branch for all users of the repository. Once you are in the remote repository, click on settings, then specify the default branch name under the main branch section. This will change the default branch for all users. This is the branch that will be checked out after users clone the repository, and is their default remote tracking branch. Finally, we will discuss viewing tracking branch status. The git status command includes tracking branch status. You can see here that you are locally on the master branch, and that there is a tracking branch named origin slash master. Git is telling us that we are up to date with the tracking branch, which means that as of the last time that we issued a network command like fetch, we have the latest commit in our local repository, and our local master branch label points to that same commit. The git status command will inform you if the cached tracking branch information is out of sync with your local branch. Let's look at an example. We start by making a local commit. We then execute git status. Notice that it says that your local branch is ahead of the tracking branch by one commit. It recommends that you execute git push so that this new local commit will be added to the remote repository. Note that git status uses cached information from the last time that a command like fetch was executed. The tracking branch is a representation of the associated branch on the remote repository. If someone else made a commit since you last executed any network command like fetch, you would not know it by executing git status. Use git log with the all option to see a combined log of the commits of all local and tracking branches. Let's look at an example. We start by editing fileA.txt. This adds uncommitted changes to the working tree. We then add fileA.txt. to the staging area. We then commit the changes. Then we execute the git log command specifying the all option. This gives us a view of the local branches and the remote tracking branches. We can see that the local master branch is one commit ahead of the tracking branch. This means that the local repository has a commit that the remote repository does not have. Here is a review of what we've discussed in this video. Tracking branches are local branches that represent remote branches. They are named <remote>/<branch> for example origin/master. They can become out of sync with local branches, and they are updated with network commands like clone, fetch, pull, and push. Now, it's time for you to work on some of the topics discussed in this video. Separate hands-on instructions are provided for you.