This video discusses tracking branches. We will start with the tracking branch overview. A tracking branch is a local branch that represents a remote branch. Locally, a tracking branch name starts with the remote name, then a forward slash, and then the branch name. If you clone a repository, they'll have a default local tracking branch. In this example, the remote repository contains a master branch with three commits. On the remote repository, the head reference points to the default branch that will be checked out when the repository is cloned. In this case, the default branch is named master. When we clone the remote repository, the same three commits, master branch label, and head reference will be copied to the local repository. You can see that the commit graph on the remote repository looks exactly like this part of the commit graph locally. After the clone, you will have the master branch checked out. You can see that there is an additional branch label on the local repository. This is the tracking branch. It represents the remote master branch. Origin is a shortcut for the URL to the remote repository, and master is the name of the branch on the remote repository. Because the clone just happened, these two repositories are synchronized. All of the master branch labels point to commit C, that includes the local master branch label, the tracking master branch label, and the remote master branch label. You can see that these three branches are related. Right now, they each contain the same three commits. A tracking branch is related to its associated remote branch and local branch, but they are decoupled. Tracking branches update separately from both the remote branch and the local branch. This is because tracking branches are only updated with network commands like clone, fetch, pull, and push. The tracking branch acts as a sort of intermediary between the local and remote branches. In this example, our tracking branch points to commit C. This means that at the time of the most recent network command, commit C was the latest commit on the remote master branch. Locally, we then created commit D. This moves the head reference and master branch label to commit D. The tracking branch label stays behind because it only moves with network commands. Committing is a local command. If we look at the remote repository, we can see that since our last network command, someone pushed a new commit E. We are now in a state where the three master branch labels point to different commits. The local master branch label points to commit D, the master tracking branch label points to commit C, and the remote master branch label points to commit E. The three related branches are no longer in sync. Next, we will discuss viewing tracking branch names. We have seen that cloning a remote repository automatically creates a tracking branch. Let's see this in action using Bitbucket and SourceTree. You will do something very similar in the lab that follows this video. We will start from scratch and create a remote repository that we will later clone. After logging into Bitbucket, click on the plus sign, and then under create a new, select repository. In this case, we named our repository ProjectE. We then click on create repository, and the remote repository is created. We want to clone this repository, but to automatically set up a tracking branch, it can't be empty. We usually make commits from SourceTree and then push them to a remote repository, but you can actually make commits right in the Bitbucket interface. In other words, the Bitbucket interface can act as a lightweight Git client. When you create a Bitbucket repository, there's a button named create README, that will create a commit in the repository. We click on that button to create a simple README file. We then create a simple README file and click commit. For the commit message, we specify add README.md. We clicked the commit button, and the first commit is made in the remote repository. In Bitbucket, you can then view the new commit. Here, we see our first commit with the commit message that we just entered. Next, we want to clone the ProjectD repository so that we have a local repository. You can click on the plus sign in Bitbucket, select the clone this repository link. And then in the window that opens, you can select clone in SourceTree. SourceTree will open with your clone to ProjectE repository. When we view the local ProjectE repository in SourceTree, we can see that there are three labels associated with our initial commit. The first label is the master label, this is the tip of our local master branch. The second label says origin/master, this is the tip of the tracking branch. Our local repository tracks the master branch of the remote repository, which is named origin as a shortcut. The third label says origin/HEAD, this label points to the tip of the default branch of the remote repository, which is the master branch. This is the branch that is checked out when you clone a repository. You will mostly see this label next to the origin/master label. If you look under the branches section on the left, you will see local branches. Here, we see the master branch, and because of the circle, you can see that is checked out. If you look under the remote section, you will see any remote repositories associated with this local repository, as well as their tracking branches. We have a single remote repository, and its shortcut name is origin. Origin shows two entries. The first is HEAD, which represents the tip of the default branch on the remote repository. The second is master, which is the origin/master tracking branch. Cloning the repository automatically set up this tracking branch. We can see that the three labels in our commit graph correspond to the three labels under branches and remotes. Finally, we will discuss viewing tracking branch status. Let's create a commit in the local repository and see what happens to our tracking branch. Here, we have modified the README.md file, appending a line of text to the file. We have then added the file to the staging area and clicked commit. We specified a commit message and then clicked commit to create the second commit in the local repository. Notice that we did not check the push changes immediately to origin/master checkbox. We will push the changes to the remote repository later. After creating the local commit, SourceTree shows you indications that the local and remote repositories are no longer synchronized. The latest commit on the commit graph has the local master branch label. Next to that label is the message 1 ahead. This means that the local master branch has one commit more than the tracking branch. You can see that the original commit still holds the labels related to origin. You can see that the tracking branch is not the same as the local master branch. If you look under branches, you'll see there is a one and then up arrow next to the local master branch. This means that this local branch is one commit ahead of its track tracking branch. Finally, the push button now has a number one message. This means that the local repository has one more commit than the remote tracking branch, and you can click push to synchronize the local and remote branches. If at any time the commit graph does not look like what you are expecting, you might want to check the column filters to make sure that you're displaying what you want. You can see three filters here. The first says, "All branches." This is the default setting. You can change this to view the current branch or any branch in the repository. The second says, "Show remote branches." This is the default setting. The other option is to hide remote branches. The third says, "Ancestor order." This also is the default setting. You could also choose to order the commits in the graph by date. If you click the push button, SourceTree will ask you which branch you would like to push to the remote repository. In this case, there is only one branch, so you select master and click okay to push the latest commit to the remote repository on Bitbucket. After the push, you can see that the three branch labels are now on the most recent commit and all of the sourced tree messages related to being one commit ahead are gone. The local and remote repositories are again synchronized. Here's a review of what we've discussed in this video. Tracking branches are local branches that represent remote branches. They are named <remote>/<branch>, for example origin/master. They can become out of sync with local branches and they are updated with network commands like clone, fetch, pull, and push. Now, it's time for you to work on some of the topics discussed in this video. Separate hands-on instructions are provided for you.