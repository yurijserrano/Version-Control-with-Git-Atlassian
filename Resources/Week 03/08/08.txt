This video discusses Rebasing. We'll start with the Rebasing overview. We start with a warning. The topics discussed here rewrite the commit history, so this should be done with caution. There is a general rule related to Rebase. Do not rewrite history that has been shared with others. If you've been working locally or if you know that no one else has used your branch you can safely Rebase it. There are two types of Rebase, a regular Rebase and an interactive Rebase. These can be very different as we will see. A rebase moves commits to a new parent or base. If we look at the example on the left, we have a situation that would typically involve a "merge commit" because commit D has been made after the featureX branch was made. However, there is another option and that is to rebase. What rebasing does is take commit B and C and moves them to a new parent commit D. The result is that you no longer need a merge commit and the merge can be fast forwarded. Because the commits have been moved, they are reapplied on top of the new commit. This creates a different ancestor chain and as a result each of the commit IDs change. So in this example commit B changes to B prime and commit C changes to C prime. You can see that this is necessary because before the rebase commit B's parent was A. And after the rebase commit B prime's parent is D. To help understand how Rebasing works, we can look at DIFFS. We know that each commit contains a snapshot of the complete project, however, it can calculate the difference between two commits. This is known as a diff or a patch. So commit A has the entire project, commit B has the entire project. It can calculate diff AB which is the difference between commits A and B. The same goes for commits B and C. Diff BC is the difference between commits B and C. When rebasing, git applies the diffs to the new parent commit. This is called "reapplying commits." In the before commit graph on the left, we can see that the parent of B is A and the parent of C is B and the difference between B and A is diff AB and the difference between C and B is diff BC. With rebasing, Git takes the difference between A and B and applies it with a parent of commit D. This creates a new commit ID. It then applies the difference between commits B and C and creates commit C prime. Reapplying commits is a form of merge and is susceptible to merge conflicts. If we look at this simple example commit B change fileA.txt one way and commit C changed fileA.txt in a different way. Reapplying commit B onto commit C creates a merge conflict because Git does not know how to write fileA.txt. Rebasing has pros and cons, the pros are that you can incorporate changes from the parent branch, so if that branch has new features or bug fixes, you will see them. The tests on your branch are using more current code and because you are keeping up with the changes on other branches the eventual merge into the base branch will be easier. Another big advantage of Rebasing is that it avoids unnecessary merge commits. You can then have a very well-defined and clean commit history. The downside of Rebasing is it's a form of merge, so merge conflicts may need to be resolved. We've also pointed out that if you've already shared your commits that can cause problems because the commit IDs change in a Rebase. And finally with the Rebase you are not preserving the commit history, you are rewriting the commit history. Next we will discuss Executing a rebase. There are two basic ways that you can execute a "git rebase." The first is to check out the feature branch and then execute "git rebase" specifying the upstream argument which is something like the master branch. This will change the parent of the currently checked out branch to the tip of the upstream branch. In the second option, you don't have to check out the feature branch first, you specify it as the second argument of the git rebase command. In the example here, "git checkout featureX" and "git rebase master" is equivalent to "git rebase master featureX." Next we will discuss Rebasing with merge conflicts. Because rebasing is a form of merge, merge conflicts can arise and what happens is you check out the feature branch, execute "git rebase master" and git informs you that there is a merge conflict. You can execute "git status" and see that both commits have modified the same file in different ways. Then you fix the file resolving the conflict markers, add it to the staging area and then execute "git rebase continue." Let's look at an example of a rebase with a merge conflict. We start by looking at our commit graph. You can see that the head refers to the feature branch and there is another commit on the master branch. We want to rebase the feature branch onto the master branch. We execute "git rebase master" and git will start by replaying the commits on top of the new commit. It will notice a merge conflict and modify fileA.txt and ask you to resolve the problem and execute "git rebase continue" after the problem has been resolved. We can execute the "git status" command and git shows you that you are currently in a rebase and that fileA.txt has been modified and placed in the working tree. We can view fileA.txt and see the conflict markers. We then edit the file, so that it looks the way that we want. We add the file to the staging area and then execute "git rebase continue." Executing "git status" again shows that there is nothing to commit and the working tree is clean and see that after the rebase we have a nice linear graph. If you begin the rebase and it has a merge conflict, you can use the abort option to get back to the pre-rebase state. Here we check out the feature branch, we then execute "git rebase master" and we see that there is a "merge conflict." We can then execute "git rebase" with the "abort option" to abort that rebase. And git status shows that we have nothing to commit and the working tree is clean. This shows the difference between resolving a merge conflict using a merge commit and using Rebase. On the left we see the merge commit flow. We start by checking out the master branch and merging in the featureX branch. Git shows us there's a conflict, git status shows that the fileA.txt file now has conflict markers. You fix fileA.txt, add it to the staging area and execute "git commit." When Rebasing you start by checking out the featureX branch and execute "git rebase master," this will show a conflict. Git status will show that fileA.txt has the conflict markers, you'll fix and add the file as before but this time you will execute "git rebase" with the "continue option." Here's a review of what we've discussed in this video. Rebasing moves a branch to the tip of another branch. Rebasing is a form of merge and may result in merge conflicts. Now it's time for you to work on the topics discussed in this video. Separate Hands-on instructions are provided.