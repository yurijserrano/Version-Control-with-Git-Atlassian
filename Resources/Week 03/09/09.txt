This video discusses rewriting history. We will start by talking about amending a commit. You can change the most recent commit. This includes changing the commit message, and/or changing the project files. This creates a new SHA-1, rewriting the history of the commit. Here's an example where our commit message has a typo, and we want to change it. We click on commit, and then we select amend last commit under the commit options. We can fix our typo and click commit. So, history will warn you that you're changing the project history because you're creating a new SHA-1. You click okay, and the commit will be amended. Now the typo in the commit message is fixed, and the commit has a new SHA-1. You can also amend the committed files, so let's say that we wanted to change or add some text to the previous commit, we change the file, we add it to the stage, and then we click commit. Again, we select amend last commit, we can keep the commit message the same, and click commit and the result is still a single commit with the correct files. Next, we will discuss interactive rebase. Interactive rebase lets you edit multiple commits. The commits can belong to any branch. In fact, they can belong to a single branch. With interactive rebase, the commit history is changed. So, if you've shared your commits, you in general don't want to use interactive rebase, and the way that it works, is that the commits after the selected commit can be modified. In this example, before the interactive rebase, we have a master branch with three commits A, B, and C. And after the interactive rebase, we have combined commits B and C into a single commit B prime. Here are the options that you have when you use interactive rebase on a branch. For each commit on the branch, you can use the commit as it is, you can edit its commit message, you can stop the rebase and amend or edit the commit, you can drop or delete a commit, you can squash the commit, which we'll talk about later, and you can also reorder the commits.. Let's look at an example where we edit a commit message. Here before the rebase, we have three commits, and the second commit has a typo in the commit message. After the rebase, we still have three commits but the typo is no longer in the commit message. The rebase changes the commit history, and therefore, commit ID B changes to commit ID B prime, and commit ID C changes to commit ID C prime. To edit a commit message in source tree, you right click on the initial commit and select rebase children interactively. This will bring up an editor allowing you to change the two commits on the branch. To edit the commit message, we select the commit and then click Edit message. Once we have completed the interactive rebase, the messages are correct and the two most recent commit IDs have changed. Another example is to edit the files of a commit. In this case, before the rebase we have three commits, but in commit B we accidentally have a typo in the file name. After the rebase, we've fixed the typo in the file name, and we have new commit IDs B prime and C prime. To edit the commit using source tree, we right click on the first commit of the branch, and select Rebase children interactively. This brings up the commit editor. Since we want to change the highlighted commit, we select the amend commit checkbox and click okay. In our history, we will see that the amended commit is checked out, so we are in a detached head state. At this point, we can go ahead and fix the commit and stage the new files. Here, we've deleted the file with a typo and added the correct file. We then click commit, and we can change the commit message if we want to. At this point, we have a branch in our history and we want to continue the interactive rebase. Under source tree's actions menu, you select continue rebase. And the result is a linear commit graph with fileB.txt fixed. You can see that the original commit is still in the commit history. To delete a commit, you again right click on the initial commit and select rebase children interactively, you highlight the commit that you want to delete. Here you can see that this is the commit with a typo in the filing. Select delete, and then select okay to continue the rebase. And we are left with a clean commit history. Squashing a commit does three main things: it applies a newer commit to an older commit. The newer commit is called the squashed commit. It combines their commit messages and then it removes the newer commit. Let's say in this example that we would like to simplify the commit history so that there is only one commit related to adding feature one. We right click on the initial commit, and select rebase children interactively. We would like to squash these two commits into a single commit, so we select the newer commit, and then click squash with previous. Source tree shows that two commits will be combined into a single commit. Click okay to continue the rebase. After the rebase, we have a single commit related to feature one. So we have squashed or combined the two commits into a single commit. Let's take a look at the difference between a squash and a delete. A squash combines the commits and creates a single commit, the work of both commits is included. Deleting a commit means that no changes from this commit are applied to any other commit. The diff is thrown out meaning that any changes that were made in this commit will be discarded. The work of a deleted commit is lost, and you have a greater chance of a merge conflict because some of the transitional work might be lost. Here's an example of the difference between a squash and a delete. Before the rebase, we have three commits; commit A adds fileA.txt, commit B adds fileB.txt, and commit C adds fileC.txt. After an interactive rebase where we squash commit C, we have a commit B prime that still contains all of the work of the three original commits. After an interactive rebase where we delete commit B, the work of adding fileB.txt is gone and we are left with commit C prime, fileA.txt, and fileC.txt. Here's a review of what we've discussed in this video. You can amend the most recent commits message, and/or committed files. This will create a new SHA-1 for the commit. Interactive rebase allows you to rewrite the history of a branch. A squash reduces multiple commits into a single commit. Now, it's time for you to work with the topics discussed in this video. Separate hands-on instructions are provided.